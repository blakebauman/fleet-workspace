---
alwaysApply: true
description: Cloudflare Workers Development Standards
---

# Cloudflare Workers Development Standards

## Core Rules

- Generate code in TypeScript by default unless JavaScript is specifically requested
- Use ES modules format exclusively (NEVER use Service Worker format)
- Keep all code in a single file unless otherwise specified
- Use official SDKs when available for service integrations
- Minimize external dependencies, avoid libraries with FFI/native/C bindings
- Never bake secrets into code
- Include proper error handling and logging
- Set compatibility_date = "2025-03-07" and compatibility_flags = ["nodejs_compat"]
- Enable observability with enabled = true and head_sampling_rate = 1
- Use WebSocket Hibernation API instead of legacy WebSocket API in Durable Objects
- Use this.ctx.acceptWebSocket(server) instead of server.accept()
- Implement webSocketMessage() and webSocketClose() handlers in Durable Objects
- Use Durable Objects for strongly consistent state management and storage
- Use Workers KV for key-value storage and configuration data
- Use D1 for relational data and SQL operations
- Use R2 for object storage and file uploads
- Use Hyperdrive to connect to existing PostgreSQL databases
- Use Queues for asynchronous processing and background tasks
- Use Vectorize for embeddings and vector search
- Use Workers Analytics Engine for event tracking and metrics
- Use Workers AI as default AI API for inference requests
- Use Browser Rendering for remote browser capabilities and Puppeteer APIs
- Use Workers Static Assets for hosting frontend applications
- Include all necessary bindings in wrangler.jsonc configuration
- Add appropriate environment variable definitions
- Implement proper request validation and security headers
- Return appropriate HTTP status codes and meaningful error messages
- Optimize for cold starts and minimize unnecessary computation
- Use appropriate caching strategies and consider Workers limits
- Implement streaming where beneficial
- Use the agents package to build AI Agents when requested
- Use this.setState API to manage state within Agents
- Use useAgent React hook for client interfaces
- Extend Agent class with proper type parameters: class AIAgent extends Agent<Env, MyState>
- Set migrations[].new_sqlite_classes to the Agent class name in wrangler.jsonc
- Always import all methods, classes and types used in generated code
- Follow Cloudflare Workers security best practices
- Include proper error boundaries and handle edge cases gracefully
- Implement proper CORS handling when needed
- Use least privilege principle for bindings
- Sanitize user inputs and implement request validation
- Include basic test examples and curl commands for API endpoints
- Provide example environment variable values
- Add sample requests and responses for clarity
- Use AI Gateway for caching, logging and instrumenting AI requests when appropriate
- Implement structured JSON outputs with JSON mode for AI responses
- Use response_format with json_schema for structured AI outputs
- Handle WebSocket upgrade requests explicitly with Upgrade header validation
- Use fan-in/fan-out patterns for WebSocket management in Durable Objects
- Implement proper error handling for WebSocket connections
- Use this.sql API within Agents for SQLite database access when beneficial
- Schedule tasks using this.schedule API within Agents
- Use routeAgentRequest for automatic routing in Agent applications
- Implement proper state synchronization between Agents and clients
- Use AI coding assistants for code generation, debugging, and optimization
- Implement proper prompt engineering for AI coding tasks
- Use structured outputs for code generation and analysis
- Implement proper error handling for AI coding operations
- Use streaming responses for real-time code assistance
- Implement proper validation for AI-generated code
- Use appropriate AI models for different coding tasks
- Implement proper security measures for AI coding operations
- Use proper logging and monitoring for AI coding activities
- Implement proper rate limiting for AI coding requests

## Configuration Requirements
- Always provide wrangler.jsonc (not wrangler.toml)
- Include appropriate triggers (http, scheduled, queues)
- Include required bindings and environment variables
- Set compatibility_date = "2025-03-07"
- Set compatibility_flags = ["nodejs_compat"]
- Set observability.enabled = true and head_sampling_rate = 1
- Include routes and domains only if applicable
- Do not include dependencies in wrangler.jsonc
- Only include bindings that are used in the code
- Include AI service bindings when using AI coding assistants
- Configure proper rate limiting for AI operations
- Set appropriate timeout values for AI requests

## WebSocket Guidelines
- Use Durable Objects WebSocket Hibernation API for WebSocket handling
- Use this.ctx.acceptWebSocket(server) to accept connections
- Define async webSocketMessage() handler for received messages
- Define async webSocketClose() handler for closed connections
- Handle WebSocket upgrade requests explicitly with Upgrade header validation
- Do not use addEventListener pattern inside Durable Objects

## Agents Guidelines
- Strongly prefer agents package for building AI Agents
- Use streaming responses from AI SDKs
- Use this.setState API for state management within Agents
- Use this.sql API for direct SQLite database interaction when beneficial
- Use useAgent React hook for client interfaces
- Provide valid Durable Object bindings in wrangler.jsonc
- Set migrations[].new_sqlite_classes to Agent class name
- Use this.schedule API for scheduling future tasks within Agents
- Use routeAgentRequest for automatic routing in Agent applications
- Implement proper state synchronization between Agents and clients
- Use named addressing for convenience: getAgentByName<Env, AgentType>(env.AIAgent, 'name')
- Use Durable Objects-style addressing for custom ID generation and control

## AI Guidelines
- Use Workers AI as default AI API for inference requests
- Use AI Gateway for caching, logging and instrumenting AI requests when appropriate
- Implement structured JSON outputs with JSON mode for AI responses
- Use response_format with json_schema for structured AI outputs
- Use OpenAI SDK with proper API key management
- Support both json_schema and json_object response formats
- Implement proper error handling for AI API calls
- Use streaming responses from AI SDKs when possible
- Include proper TypeScript interfaces for AI response schemas

## AI Coding Assistant Guidelines
- Use AI coding assistants for code generation, debugging, and optimization
- Implement proper prompt engineering for coding tasks
- Use structured outputs for code generation and analysis
- Implement proper validation for AI-generated code
- Use appropriate AI models for different coding tasks
- Implement proper security measures for AI coding operations
- Use proper logging and monitoring for AI coding activities
- Implement proper rate limiting for AI coding requests
- Use streaming responses for real-time code assistance
- Implement proper error handling for AI coding operations
- Use proper code review and testing for AI-generated code
- Implement proper version control for AI-assisted development
- Use appropriate AI models for code generation vs. analysis
- Implement proper context management for AI coding sessions
- Use proper documentation for AI-assisted code
- Implement proper testing strategies for AI-generated code
- Use proper security scanning for AI-generated code
- Implement proper backup and recovery for AI coding sessions
- Use proper collaboration tools for AI-assisted development
- Implement proper quality assurance for AI-generated code

## AI Model Selection Guidelines
- Use GPT-4 for complex code generation and analysis
- Use GPT-3.5-turbo for simple code tasks and debugging
- Use Claude for code review and optimization
- Use CodeLlama for code-specific tasks and generation
- Use appropriate models for different programming languages
- Consider model costs and performance requirements
- Use fine-tuned models for domain-specific coding tasks
- Implement proper model fallback strategies
- Use appropriate models for different code complexity levels
- Consider model context length for large codebases

## AI Prompt Engineering Guidelines
- Use clear and specific prompts for coding tasks
- Include proper context and requirements in prompts
- Use structured prompts for complex coding tasks
- Implement proper prompt validation and sanitization
- Use few-shot learning for complex coding patterns
- Implement proper prompt versioning and management
- Use appropriate prompt templates for different tasks
- Implement proper prompt optimization strategies
- Use proper context management for long coding sessions
- Implement proper prompt security measures

## AI Code Validation Guidelines
- Implement proper syntax validation for AI-generated code
- Use proper linting and formatting tools
- Implement proper security scanning for AI-generated code
- Use proper testing strategies for AI-generated code
- Implement proper code review processes
- Use proper version control for AI-assisted development
- Implement proper backup and recovery strategies
- Use proper documentation standards for AI-generated code
- Implement proper quality assurance processes
- Use proper collaboration tools for AI-assisted development

## WebSocket Advanced Guidelines
- Handle WebSocket upgrade requests explicitly with Upgrade header validation
- Use fan-in/fan-out patterns for WebSocket management in Durable Objects
- Implement proper error handling for WebSocket connections
- Use this.ctx.getWebSockets() to track active connections
- Implement proper connection lifecycle management
- Handle WebSocket errors gracefully with webSocketError handler
- Use proper WebSocket close codes and reasons

## Examples
### Wrangler Configuration Example
```jsonc
{
  "name": "app-name",
  "main": "src/index.ts",
  "compatibility_date": "2025-03-07",
  "compatibility_flags": ["nodejs_compat"],
  "observability": {
    "enabled": true,
    "head_sampling_rate": 1
  },
  "durable_objects": {
    "bindings": [
      {
        "binding": "AIAgent",
        "class_name": "AIAgent"
      }
    ]
  },
  "migrations": [
    {
      "tag": "v1",
      "new_sqlite_classes": ["AIAgent"]
    }
  ],
  "ai": {
    "binding": "AI"
  }
}
```

### WebSocket Durable Object Example
```typescript
export class WebSocketServer extends DurableObject {
  async fetch(request: Request) {
    const webSocketPair = new WebSocketPair();
    const [client, server] = Object.values(webSocketPair);

    this.ctx.acceptWebSocket(server);

    return new Response(null, {
      status: 101,
      webSocket: client,
    });
  }

  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    ws.send(`[Server]: ${message}`);
  }

  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {
    ws.close(code, "Server closing connection");
  }
}
```

### WebSocket Fan-in/Fan-out Example
```typescript
export class WebSocketHibernationServer extends DurableObject {
  async fetch(request: Request) {
    const webSocketPair = new WebSocketPair();
    const [client, server] = Object.values(webSocketPair);

    this.ctx.acceptWebSocket(server);

    return new Response(null, {
      status: 101,
      webSocket: client,
    });
  }

  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
    // Fan-out: Send message to all connected clients
    const connections = this.ctx.getWebSockets();
    connections.forEach(connection => {
      connection.send(`[Broadcast]: ${message}`);
    });
  }

  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {
    ws.close(code, "Server closing connection");
  }

  async webSocketError(ws: WebSocket, error: unknown) {
    console.error('WebSocket error:', error);
    ws.close(1011, "Internal error");
  }
}
```

### Agent Class Example
```typescript
export class AIAgent extends Agent<Env, MyState> {
  async onRequest(request: Request) {
    // Handle HTTP requests
    return new Response("Hello from Agent");
  }

  async onConnect(connection: Connection) {
    await this.initiate(connection);
    connection.accept();
  }

  async onMessage(connection: Connection, message: WSMessage) {
    // Handle WebSocket messages
  }
}
```

### Agent with Scheduling Example
```typescript
export class AIAgent extends Agent<Env, MyState> {
  async onRequest(request: Request) {
    // Schedule a task that runs every 5 minutes
    await this.schedule("*/5 * * * *", "checkStatus", { userId: "user123" });

    return new Response("Task scheduled");
  }

  async checkStatus(data: { userId: string }) {
    // This method will be called by the scheduler
    const status = await this.checkUserStatus(data.userId);
    await this.setState({ lastCheck: new Date(), status });
  }

  async checkUserStatus(userId: string) {
    // Use SQL API for database queries
    const result = await this.sql`SELECT status FROM users WHERE id = ${userId}`;
    return result[0]?.status || 'unknown';
  }
}
```

### AI Structured Output Example
```typescript
import { OpenAI } from "openai";

interface Env {
  OPENAI_API_KEY: string;
}

const CalendarEventSchema = {
  type: 'object',
  properties: {
    name: { type: 'string' },
    date: { type: 'string' },
    participants: { type: 'array', items: { type: 'string' } },
  },
  required: ['name', 'date', 'participants']
};

export default {
  async fetch(request: Request, env: Env) {
    const client = new OpenAI({
      apiKey: env.OPENAI_API_KEY,
      // Optional: use AI Gateway
      // baseUrl: "https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai"
    });

    const response = await client.chat.completions.create({
      model: 'gpt-4o-2024-08-06',
      messages: [
        { role: 'system', content: 'Extract the event information.' },
        { role: 'user', content: 'Alice and Bob are going to a science fair on Friday.' },
      ],
      response_format: {
        type: 'json_schema',
        schema: CalendarEventSchema,
      },
    });

    const event = response.choices[0].message.parsed;
    return Response.json({ "calendar_event": event });
  }
};
```

### AI Coding Assistant Example
```typescript
import { OpenAI } from "openai";

interface Env {
  OPENAI_API_KEY: string;
}

interface CodeGenerationRequest {
  language: string;
  task: string;
  requirements: string[];
  context?: string;
}

interface CodeGenerationResponse {
  code: string;
  explanation: string;
  tests?: string;
  documentation?: string;
}

const CodeGenerationSchema = {
  type: 'object',
  properties: {
    code: { type: 'string' },
    explanation: { type: 'string' },
    tests: { type: 'string' },
    documentation: { type: 'string' }
  },
  required: ['code', 'explanation']
};

export default {
  async fetch(request: Request, env: Env) {
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 });
    }

    try {
      const body: CodeGenerationRequest = await request.json();

      const client = new OpenAI({
        apiKey: env.OPENAI_API_KEY,
      });

      const prompt = `Generate ${body.language} code for the following task:
Task: ${body.task}
Requirements: ${body.requirements.join(', ')}
${body.context ? `Context: ${body.context}` : ''}

Please provide:
1. Clean, well-documented code
2. A clear explanation of the solution
3. Unit tests for the code
4. Documentation comments

Use best practices and follow ${body.language} conventions.`;

      const response = await client.chat.completions.create({
        model: 'gpt-4o-2024-08-06',
        messages: [
          { role: 'system', content: 'You are an expert software developer. Generate high-quality, production-ready code with proper error handling, tests, and documentation.' },
          { role: 'user', content: prompt }
        ],
        response_format: {
          type: 'json_schema',
          schema: CodeGenerationSchema,
        },
        temperature: 0.3,
        max_tokens: 4000,
      });

      const result: CodeGenerationResponse = response.choices[0].message.parsed;

      return Response.json({
        success: true,
        data: result
      });

    } catch (error) {
      console.error('AI coding assistant error:', error);
      return Response.json({
        success: false,
        error: 'Failed to generate code'
      }, { status: 500 });
    }
  }
};
```

### AI Code Review Example
```typescript
import { OpenAI } from "openai";

interface Env {
  OPENAI_API_KEY: string;
}

interface CodeReviewRequest {
  code: string;
  language: string;
  context?: string;
}

interface CodeReviewResponse {
  issues: Array<{
    severity: 'low' | 'medium' | 'high' | 'critical';
    line?: number;
    message: string;
    suggestion?: string;
  }>;
  suggestions: string[];
  score: number;
  summary: string;
}

const CodeReviewSchema = {
  type: 'object',
  properties: {
    issues: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          severity: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] },
          line: { type: 'number' },
          message: { type: 'string' },
          suggestion: { type: 'string' }
        },
        required: ['severity', 'message']
      }
    },
    suggestions: { type: 'array', items: { type: 'string' } },
    score: { type: 'number' },
    summary: { type: 'string' }
  },
  required: ['issues', 'suggestions', 'score', 'summary']
};

export default {
  async fetch(request: Request, env: Env) {
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 });
    }

    try {
      const body: CodeReviewRequest = await request.json();

      const client = new OpenAI({
        apiKey: env.OPENAI_API_KEY,
      });

      const prompt = `Review the following ${body.language} code for:
- Security vulnerabilities
- Performance issues
- Code quality and best practices
- Potential bugs
- Maintainability concerns

Code:
\`\`\`${body.language}
${body.code}
\`\`\`

${body.context ? `Context: ${body.context}` : ''}

Provide a comprehensive code review with:
1. Specific issues found (with severity levels)
2. Improvement suggestions
3. Overall code quality score (1-10)
4. Summary of findings

Focus on actionable feedback that improves code quality and security.`;

      const response = await client.chat.completions.create({
        model: 'gpt-4o-2024-08-06',
        messages: [
          { role: 'system', content: 'You are an expert code reviewer with deep knowledge of software engineering best practices, security, and performance optimization.' },
          { role: 'user', content: prompt }
        ],
        response_format: {
          type: 'json_schema',
          schema: CodeReviewSchema,
        },
        temperature: 0.2,
        max_tokens: 3000,
      });

      const result: CodeReviewResponse = response.choices[0].message.parsed;

      return Response.json({
        success: true,
        data: result
      });

    } catch (error) {
      console.error('AI code review error:', error);
      return Response.json({
        success: false,
        error: 'Failed to review code'
      }, { status: 500 });
    }
  }
};
```

### React Agent Client Example
```typescript
// React client hook for the agents
import { useAgent } from "agents/react";
import { useState } from "react";

function AgentInterface() {
  const connection = useAgent({
    agent: "dialogue-agent",
    name: "insight-seeker",
    onMessage: (message) => {
      console.log("Understanding received:", message.data);
    },
    onOpen: () => console.log("Connection established"),
    onClose: () => console.log("Connection closed"),
  });

  const inquire = () => {
    connection.send(JSON.stringify({
      type: "inquiry",
      content: "What insights have you gathered?",
    }));
  };

  return (
    <div>
      <button onClick={inquire}>Seek Understanding</button>
    </div>
  );
}

function StateInterface() {
  const [state, setState] = useState({ counter: 0 });
  const agent = useAgent({
    agent: "thinking-agent",
    onStateUpdate: (newState) => setState(newState),
  });

  const increment = () => {
    agent.setState({ counter: state.counter + 1 });
  };

  return (
    <div>
      <p>Count: {state.counter}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

## Service-Specific Guidelines
### Durable Objects
- Use for strongly consistent state management and storage
- Implement proper error handling with try-catch blocks
- Use this.ctx.waitUntil() for background operations
- Implement proper cleanup in webSocketClose handlers
- Use this.ctx.getWebSockets() to track active connections
- Consider using this.ctx.scheduledTime for time-based operations

### Workers KV
- Use for key-value storage and configuration data
- Implement proper error handling for KV operations
- Use appropriate TTL values for cached data
- Consider using KV for A/B testing and feature flags
- Implement retry logic for failed KV operations

### D1 Database
- Use for relational data and SQL operations
- Implement proper SQL injection prevention
- Use parameterized queries with this.sql
- Implement connection pooling best practices
- Use transactions for multi-step operations

### R2 Storage
- Use for object storage and file uploads
- Implement proper content-type headers
- Use presigned URLs for secure file access
- Implement proper error handling for upload failures
- Consider using R2 for AI assets and image storage

### Queues
- Use for asynchronous processing and background tasks
- Implement proper error handling and retry logic
- Use batch processing when possible
- Implement dead letter queues for failed messages
- Consider using queues for email notifications and webhooks

### Workers AI
- Use as default AI API for inference requests
- Implement proper rate limiting and error handling
- Use streaming responses when possible
- Implement proper prompt engineering practices
- Consider using AI Gateway for enhanced features

### Hyperdrive
- Use to connect to existing PostgreSQL databases
- Implement proper connection pooling
- Use prepared statements for performance
- Implement proper error handling for connection failures
- Consider using for legacy system integration

### AI Coding Services
- Use AI coding assistants for code generation and review
- Implement proper prompt engineering for coding tasks
- Use structured outputs for code analysis
- Implement proper validation for AI-generated code
- Use appropriate AI models for different coding tasks
- Implement proper security measures for AI coding operations
- Use proper logging and monitoring for AI coding activities
- Implement proper rate limiting for AI coding requests
- Use streaming responses for real-time code assistance
- Implement proper error handling for AI coding operations

## Error Handling Guidelines
- Implement proper error boundaries and try-catch blocks
- Return appropriate HTTP status codes (400, 401, 403, 404, 500)
- Provide meaningful error messages without exposing internals
- Log errors appropriately with proper context
- Handle edge cases gracefully
- Implement proper validation for all inputs
- Use proper error types and interfaces
- Implement retry logic for transient failures
- Use proper error codes for different failure types
- Handle AI-specific errors gracefully
- Implement proper fallback strategies for AI failures
- Use proper error reporting for AI coding operations

## Security Guidelines
- Never bake secrets into code
- Use environment variables for sensitive data
- Implement proper authentication and authorization
- Use least privilege principle for bindings
- Sanitize all user inputs
- Implement proper CORS policies
- Use HTTPS for all external communications
- Implement rate limiting where appropriate
- Use proper security headers
- Validate all incoming requests
- Implement proper security scanning for AI-generated code
- Use proper access controls for AI coding operations
- Implement proper audit logging for AI activities
- Use proper encryption for AI data and communications
- Implement proper input validation for AI prompts

## Performance Guidelines
- Optimize for cold starts
- Minimize unnecessary computation
- Use appropriate caching strategies
- Consider Workers limits and quotas
- Implement streaming where beneficial
- Use proper async/await patterns
- Minimize external API calls
- Use appropriate data structures
- Implement proper connection pooling
- Consider using edge caching strategies
- Optimize AI model selection for performance
- Implement proper caching for AI responses
- Use streaming for large AI operations
- Optimize prompt engineering for efficiency
- Implement proper rate limiting for AI operations

## AI Development Workflow Guidelines
- Use AI coding assistants for initial code generation
- Implement proper code review for AI-generated code
- Use AI for code optimization and refactoring
- Implement proper testing for AI-generated code
- Use AI for documentation generation
- Implement proper version control for AI-assisted development
- Use AI for code analysis and debugging
- Implement proper quality assurance for AI-generated code
- Use AI for performance optimization
- Implement proper collaboration tools for AI-assisted development
- Use AI for security analysis and vulnerability detection
- Implement proper backup and recovery for AI coding sessions
- Use AI for code migration and modernization
- Implement proper monitoring for AI-assisted development
- Use AI for code maintenance and updates
